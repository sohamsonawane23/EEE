section .bss
    num1 resb 1     ; reserve 1 byte for first number
    num2 resb 1     ; reserve 1 byte for second number

section .text
    global _start

_start:
    ; Read first number (1 byte)
    mov eax, 3           ; sys_read
    mov ebx, 0           ; stdin
    mov ecx, num1        ; buffer for num1
    mov edx, 1           ; 1 byte to read
    int 0x80

    ; Read second number (1 byte)
    mov eax, 3
    mov ebx, 0
    mov ecx, num2
    mov edx, 1
    int 0x80

    ; Convert ASCII input to integer (assuming input '0'-'9')
    mov al, [num1]
    sub al, '0'          ; convert char to number
    mov bl, al           ; move to bl to use later

    mov al, [num2]
    sub al, '0'

    ; Prepare registers for division
    mov ah, 0            ; clear ah for 16-bit dividend in ax
    mov al, bl           ; dividend (first number) in al
    mov bl, al           ; divisor in bl (second number)

    ; Actually, for div instruction (8-bit divisor), 16-bit dividend (ax) is divided.

    ; So, set dividend properly
    mov ax, bx           ; dividend in ax (num1)
    mov bl, al           ; divisor in bl (num2)

    ; But we need to put dividend in ax and divisor in bl
    ; Re-do conversion precisely:

    ; Reload num1 and num2 values into registers
    mov al, [num1]
    sub al, '0'
    mov ah, 0            ; clear ah to get full 16-bit dividend

    mov bl, [num2]
    sub bl, '0'

    ; Dividend in ax, divisor in bl
    mov ax, ax           ; just to indicate dividend in ax
    div bl               ; divide ax by bl

    ; After div:
    ; quotient in al
    ; remainder in ah

    ; Store quotient and remainder in bss for viewing or debugging
    mov [num1], al       ; quotient
    mov [num2], ah       ; remainder

    ; Exit program
    mov eax, 1
    xor ebx, ebx
    int 0x80